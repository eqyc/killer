# 0003. 实施 CQRS 模式

- **状态**: 已接受
- **决策者**: 架构组
- **日期**: 2024-01-15
- **技术故事**: KILLER-42

## 背景与问题陈述

KILLER ERP 系统面临读写负载特征差异显著的挑战。写操作（如创建凭证���提交订单）需要强一致性和事务保证，而读操作（如报表查询、数据分析）需要高吞吐量和复杂的聚合计算。

传统的 CRUD 模式使用同一数据模型处理读写操作，在我们的场景下存在明显问题：复杂的报表查询会锁定事务表，影响写入性能；为了优化查询而添加的索引会拖慢写入速度；单一模型难以同时满足 OLTP 和 OLAP 的需求。

我们需要一种架构模式来解耦读写关注点，使系统能够独立优化读写路径。

## 决策驱动因素

- **读写负载分离**: 写操作需要 ACID，读操作需要高吞吐
- **查询复杂度**: 报表需要跨多表聚合，不适合在事务库执行
- **扩展性**: 读写需要独立扩展
- **实时性**: 读模型可以接受秒级延迟
- **复杂度控制**: 避免过度设计

## 考虑的方案

### 方案 1: 传统 CRUD + 读副本

使用 PostgreSQL 主从复制，写操作走主库，读操作走从库。

**优点**:
- 架构简单，易于理解
- 无需额外的数据同步机制
- 运维成熟，工具丰富

**缺点**:
- 读写使用相同数据模型，查询优化受限
- 复杂报表仍会影响从库性能
- 无法针对读场景优化数据结构

### 方案 2: CQRS（命令查询职责分离）

将系统分为命令端（写）和查询端（读），使用不同的数据模型。命令端使用规范化的事务模型，查询端使用反规范化的查询优化模型。

**优点**:
- 读写模型独立优化
- 查询端可使用专门的分析数据库
- 支持复杂的物化视图
- 读写可独立扩展

**缺点**:
- 架构复杂度增加
- 需要处理数据同步和最终一致性
- 开发和调试成本上升
- 需要额外的基础设施

### 方案 3: 完整事件溯源 + CQRS

在 CQRS 基础上，命令端使用事件溯源存储所有状态变更事件，查询端通过事件投影构建。

**优点**:
- 完整的审计轨迹
- 支持时间旅行查询
- 事件可重放构建新视图

**缺点**:
- 复杂度最高
- 事件存储和重放的性能挑战
- 团队学习成本高
- 不是所有场景都需要事件溯源

## 决策结果

**选择方案**: 方案 2 - CQRS（命令查询职责分离）

**理由**:

CQRS 模式能够有效解决我们面临的读写负载差异问题。通过分离读写模型，我们可以在命令端使用 PostgreSQL 保证事务一致性，在查询端使用 ClickHouse 提供高性能分析查询。两端可以独立扩展，互不影响。

相比完整的事件溯源方案，纯 CQRS 的复杂度更可控。我们选择在特定场景（如财务凭证、库存变动）局部应用事件溯源，而不是全系统强制使用。这种渐进式策略降低了实施风险。

数据同步通过 Kafka 消费领域事件实现，查询端订阅事件并更新物化视图。这种最终一致性模型对于报表和分析场景是可接受的，通常延迟在秒级以内。

## 积极后果

- 写操作性能不受复杂查询影响
- 报表查询可以使用专门优化的数据结构
- 读写可以独立扩展
- 为未来的实时分析奠定基础

## 消极后果

- 系统复杂度增加
- 需要处理最终一致性
- 需要维护数据同步管道
- 开发人员需要理解两套模型

## 遵从性

- 所有写操作必须通过 Command Handler 处理
- 复杂查询必须使用读模型（ClickHouse）
- 简单的单聚合查询可以直接访问写模型
- 数据同步延迟监控告警阈值：5 秒

## 相关链接

- [ADR-0004: 使用 PostgreSQL 和 ClickHouse](0004-use-postgresql-and-clickhouse.md)
- [Martin Fowler - CQRS](https://martinfowler.com/bliki/CQRS.html)
- [Microsoft - CQRS Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs)

---

## 修订历史

| 日期 | 版本 | 变更内容 | 作者 |
|------|------|----------|------|
| 2024-01-15 | 1.0 | 初始版本 | 架构组 |
